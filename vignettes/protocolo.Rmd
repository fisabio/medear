---
title: "Protocolo de georreferenciación"
author: "Grupo MEDEA"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
---

El protocolo según se ha definido consta de 3 partes separadas:

* Importación de las librerias, datos y adaptación de su formato para la geocodificación.
* Geocodificación con `caRtociudad`.
* Geocodificación de registros restantes con `Google`.

El que el protocolo contemple dos servicios de geocodificación distintos se debe a que ambos son completamente indpendientes y por tanto una dirección que no pueda ser resuelta por uno de los servicios sí podría serlo perfectamente por el otro. En nuestra experiencia el servicio de geocodoficación de `Cartociudad` resulta más fiable que el de `Google`. Según hemos podido comprobar `Google` parece bastante más aventurado a la hora de asignar cada dirección al punto que él considera oportuno. Además, las coordenadas geográficas de las direcciones de `Google` son bastante menos precisas que las de `Cartociudad`, con bastante más error alrededor del punto que debería haber sido asignado. Sin embargo el servicio de `Google` tiene una ventaja respecto al de `Cartociudad` y es que es capaz de geocodificar puntos de interés además de direccciones por lo que es capaz de resolver direcciones del tipo `Residencia Costablanca, Alicante`. Por tanto el servicio de `Google` aporta un matiz complementario que `Cartociudad` no es capaz de ofrecer por lo que resulta interesante la utilización también de este servicio.

En consecuencia el protocolo de geocodificación procede de la siguiente manera. En primer lugar todas las direcciones intentan ser geocodificadas mediante el servicio de `Cartociudad` ya que éste parece ser más fiable y no tiene limitación diaria en cuanto al número de direcciones a geocodificar. Una vez terminado ese proceso, en el que nos habremos quitado de encima buena parte de las direcciones que teníamos que geocodificar, intentaremos la geocodificación de las direcciones restantes mediante el servicio de `Google`. En adelante describimos en detalle cada una de estas fases del protocolo.

# Importación de las librerias, datos y adaptación de su formato para la geocodificación

## Carga de las librerias necesarias para el proceso de geocodificación:

```{r, message=FALSE, warning=FALSE, eval = FALSE}
if (!"devtools" %in% installed.packages()) 
  install.packages("devtools")
devtools::install_github("fisabio/medear") # Puede tardar unos minutos...
library(medear)
```

Al instalar el paquete `medear` se instalan las dependencias, que incluyen a los paquetes `ggmap` y `caRtociudad`. Se ha testado el uso de esto protocolo con las siguientes versiones de los paquetes:

* `devtools`: Versión 1.13.4
* `medear`: Versión 0.2.1
* `ggmap`: Versión 2.6.1
* `caRtociudad`: Versión 0.5.5

## Carga y preparación de la cartografía

El proceso de geocodificación hace uso de la cartografía de cada municipio para chequear que cada una de las geocodificaciones realizadas cae dentro del límite territorial de la ciudad correspondiente. En caso contrario la geocodificación realizada es desechada por considerarse errónea al suponer que la dirección se ha asignado a otro municipio.

Al haber cargado la librería `medear` dispondremos de una cartografía (descargado de la web del INE) a nivel de sección censal para el año 2011 parar todas las ciudades del proyecto MEDEA. Dicha cartografía se encuentra en el objeto `cartografia`. El `data.frame` asociado a `cartografia` tiene como columnas: `seccion`,  `CUMUN` (código INE para cada municipio), `CCA` (código INE para cada comunidad autónoma), y las variables `NPRO`, `NCA`  y `NMUN`, que hacen referencia a los nombres estandarizados de cada provincia, comunidad autónoma y municipio (respectivamente).

```{r, eval=FALSE}
# Filtramos la cartografía, en nuestro caso nos quedamos sólo con las ciudades de la 
# Comunitat Valenciana (adaptar en caso de otras CCAA)
carto.munis <- cartografia[cartografia$CCA == "10", ]
``` 

En caso de que quisiéramos cargar otra cartografía que no fuera la incluida en el paquete `medear` podríamos hacerlo. Si la cartografía estuviera en formato *ESRI Shapefile* (archivo con extensión `.shp`) sería necesario que dicho archivo lleve anexo un archivo con la proyección empleada (archivo con extensión `.prj`) con el mismo nombre que el archivo con la cartografía. Como decíamos, el archivo con extensión `.prj` contendrá la información sobre la proyección utilizada para georeferenciar la cartografía y por tanto para referenciar sus elementos exactamente dentro del globo terráqueo. Esta información resulta necesaria para ciertas fases del proceso de geocodificación. 

En caso de querer cargar un archivo de cartografía lo podremos hacer de la siguiente manera:

```{r, eval=FALSE}
# No ejecutar este comando a menos que se quiera importar un archivo de cartografía
# El paquete rgdal se instala como dependencia del paquete medear
library(rgdal)
# Cambiar CartografiaDeseada.shp y XXXXXXXX por los argumentos oportunos
carto.munis <- readOGR(dsn = "CartografiaDeseada.shp", layer = "CartografiaDeseada")
```

## Carga y preparación de los datos de mortalidad

En esta sección vamos a cargar la información de mortalidad, con sus direcciones, que nos disponemos a geocodificar. Los datos de la Comunidad Valenciana se encuentran en un objeto de `R` llamado `datosmort`. El objeto `datosmort` típicamente se cargara mediante alguna sentencia del tipo `load(...)` o `read.csv(...)` donde `...` contendrá la ruta en la que tengamos el archivo correspondiente y si acaso algún otro argumento específico de dicha lectura. Si deseas ejecutar este protocolo de forma secuencial sin cambiar nada, es importante que, una vez hayas leído tus datos en `R` uses el mismo nombre que nosotros (`datosmort`). Esto puedes hacerlo con la sentencia: `datosmort <- tu_data.frame_con_tu_mortalidad`.

En el caso de la Comunidad Valenciana el data.frame con la mortalidad tiene la siguiente estructura:

```{r, eval=FALSE}
colnames(datosmort)
# [1] "NID"        "SEXO"       "ANODEFUN"   "MESDEFUN"   "DIADEFUN"   "ANONAC"    
# [7] "MESNAC"     "DIANAC"     "TVIA"       "NVIA"       "NPOLI"      "CODMUNIRES"
# [13]"NMUNIRES"   "NPROVRES"   "CODPST"      "CAUSABASIC"
```

De esos campos los únicos que vamos a utilizar de aquí en adelante son:
* `TVIA`, tipo de vía. 
* `NVIA`, nombre de la vía.
* `NPOLI`, número de policia del domicilio. 
* `CODMUNIRES`, código INE del municipio. 
* `NMUNIRES`, nombre del municipio de residencia.
* `NPROVRES`, nombre de la provincia de residencia. 
* `CODPST`, código postal (si se tiene, si no contendrá un texto en blanco: "").

Para que el resto de instrucciones contenidas en este protocolo funcionen sin ninguna modificación adicional, tu  `data.frame` con la información de mortalidad habrá de tener (al menos) estos campos con 
exactamente estos nombres. Si los nombres de estas columnas en tu `data.frame` fueran distintos te aconsejamos que los renombres. Respecto al resto de columnas, si alguna faltara, tuvieras alguna de más o con distinto nombre, dado que no van a necesitarse no tendrá ninguna importancia para el correcto funcionamiento del protocolo.

Una vez que te hayas asegurado que tu `data.frame` tenga la información que acabamos de comentar, con ese formato exactamente, las siguientes sentencias modifican dicho `data.frame` inicializando las columnas que serán rellenadas posteriormente en el proceso de geocodificación

```{r, eval=FALSE}
datosmort$BOD.direccion <- ""    # Dirección tal cual ha sido intentada geocodificar
datosmort$georef        <- "NO"  # Status del proceso de georeferenciación
datosmort$id            <- ""
datosmort$province      <- ""
datosmort$muni          <- ""
datosmort$tip_via       <- ""
datosmort$address       <- ""
datosmort$portalNumber  <- ""
datosmort$refCatastral  <- ""
datosmort$postalCode    <- ""
datosmort$lat           <- NA_real_
datosmort$lng           <- NA_real_
datosmort$stateMsg      <- ""
datosmort$state         <- ""
datosmort$type          <- ""
```

# Georeferenciación con caRtociudad

Una vez disponemos de la base de datos de mortalidad en el formato adecuado pasamos a intentar geocodificar todas las direcciones utilizando el paquete `caRtociudad`. Para ello haremos un uso intensivo de la función `geocodificar_cartociudad` de `medear`, la cual intenta geocodificar cada dirección atendiendo a las dos versiones de `caRtociudad` disponibles a día de hoy. Para más información del funcionamiento interno de dicha función se puede recurrir a la ayuda específica de la misma (`?geocodificar_cartociudad`). Además, en caso de que una dirección no pueda ser geocodificada se prueba si distintas variantes de la dirección pudieran dar algún resultado positivo. Las variantes contempladas son 2:

* Filtro 1: Comprueba la duplicidadad del tipo de vía y la elimina si existe. Por ejemplo: `"CALLE AVDA" -> "AVDA", "CALLE PLAZA" -> "PLAZA", ...`
* Filtro 2: Elimina texto o bien contenido entre paréntesis o bien posterior a expresiones que contengan "URBANIZACIÓN xxxxx", "URB xxxxxx", "RESIDENCIA XXXXX", "RESID XXXXX" ¿¿¿¿¿¿¿SOLO ESTO O ALGO MAS, POR MARCAR CON PUNTOS SUSPENSIVOS???

El paquete `caRtociudad` manda al servicio de geocodificación las direcciones de las defunciones una a una. En caso de que la geocodificación llevada a cabo sea exitosa, completaremos los campos que hemos añadido a `datosmort` con la información que hayamos obtenido. En caso contrario simplemente actualizaremos el campo `georef` con información que podría ser de interés en relación al motivo por el que dicha defunción no ha podido ser georeferenciada.  

```{r, eval = FALSE}
# Seleccionamos individuos a georeferenciar, si se quisiera hacer una segunda 
# ronda de geocodificación (como luego haremos con Google) una sentencia de selección 
# de este tipo hará que sólo se aplique la nueva geocodificación a los registros 
# que nos parezca oportuno.

no.geo    <- which(datosmort$georef == "NO") 
totno.geo <- length(no.geo)

# Comenzamos bucle de geocodificación para los registros seleccionados
for (i in 1:totno.geo) {
  
  cont <- no.geo[i]
  
  # Preparamos la dirección (normalización y limpieza)
  aux.direc <- limpia_dir(
    tvia    = datosmort$TVIA[cont],
    nvia    = datosmort$NVIA[cont],
    npoli   = datosmort$NPOLI[cont],
    muni    = datosmort$NMUNIRES[cont],
    prov    = datosmort$NPROVRES[cont],
    codpost = datosmort$CODPST[cont]
  )

  if (aux.direc$nvia == "") {
    datosmort$georef[cont] <- "DIREC VACIA"
  } else {
    
    # Guardamos en "BOD.direccion" la dirección normalizada que vamos 
    # a mandar a Cartociudad.
    datosmort$BOD.direccion[cont] <- paste0(
      aux.direc$tvia, " ",
      aux.direc$nvia, " ",
      aux.direc$npoli, ", ",
      aux.direc$muni, " , ",
      aux.direc$prov, " , ",
      aux.direc$codpost
    )
    
    direc <- datosmort$BOD.direccion[cont]
    
    # Georeferenciación con caRtociudad con comprobación de que la 
    # geocodificación que hemos obtenido recae geográficamente dentro del 
    # límite geográfico correspondiente a la ciudad.
    aux <- geocodificar_cartociudad(
      direc    = direc,
      poligono = carto.munis[carto.munis$CUMUN == datosmort$CODMUNIRES[cont], ]
    )
    
    # En caso de que quisiéramos georeferenciar con caRtociudad sin más, 
    # sin comprobar que el punto que obtenemos está incluido en una región 
    # geográfica concreta podríamos hacer simplemente: 
    # aux <- geocodificar_cartociudad(direc = direc)
    
    columnas_elegidas <- c(
      "id", "province", "muni", "tip_via", "address", "portalNumber", "refCatastral",
      "postalCode", "lat", "lng", "stateMsg", "state", "type", "georef"
    )
    
    if (substr(aux$georef, 1, 2) != "NO") {
      datosmort[cont, columnas_elegidas] <- aux
    } else {
      datosmort$georef[cont] <- as.character(aux$georef)
      # El resultado de la geocodificación puede ser NO.XXX además de un simple NO 
      # (donde XXX nos puede aportar información adicional), ese es el motivo por 
      # el que actualizamos el valor de la columna georef del registro correspondiente. 
      
      # En caso de que la geocodificación de la dirección no haya tenido éxito,
      #  probamos la geocodificación de algunas variantes de dicha dirección.
      for (filtro in 1:2) {
        if (substr(aux$georef, 1, 2) == "NO") { 
          # Si alguno de los filtros ha funcionado no se reintentaría la geocodificación.
          aux.direcf <- filtra_dir(vias = aux.direc, filtro)
          if (aux.direcf != "") {
              direcf <- aux.direcf
              aux    <- geocodificar_cartociudad(
                direc    = direcf,
                poligono = carto.munis[carto.munis$CUMUN == datosmort$CODMUNIRES[cont], ]
              )
          }
          if(substr(aux$georef, 1, 2) != "NO") {
            datosmort[cont, columnas_elegidas] <- aux
            datosmort$georef[cont] <- paste0(datosmort$georef[cont], filtro)
          }
        }
      }
    }
  }
  #Contador
  cat(paste(i, "de", totno.geo, "georef", datosmort$georef[cont], "\n"))
}

# Una vez finalizado el proceso guardamos una copia de los datos georeferenciados por 
# caRtociudad antes de pasar a google
save(datosmort, file = "datos/datosfinalescarto/datoscarto.RData")
```

# Georeferenciación con Google

Una vez hemos concluido el procedimiento de geocodificación de `caRtociudad` querremos utilizar el servicio de geocodificación de `Google` para tratar de georeferenciar todos los registros que no hayan podido ser georeferenciados con `caRtociudad`. Además, en ocasiones también querremos regeocodificar algunas direcciones que ya hayamos mandado a `Google` en caso de que anteriormente no hubieran sido geocodifcados por `Google` por haber excedido el número máximo diario de georeferenciaciones posibles de esta herramienta o por fallos de conexión que pudiera haber en la red. Para entender mejor el código que se muestra a continuación debemos tener en cuenta que al tratar de georeferenciar con `Google` un registro la respuesta puede ser la siguiente:

* `state` igual a `"OK"` : registro georeferenciado.
* `state` distinto de `"OK"`:
    - `state` igual a `"ZERO_RESULTS"` indica que el registro no ha podido ser georeferenciado por google.
    - `state` igual a `"OVER_QUERY_LIMIT"` indica que por algún motivo (puede ser exceso de número de georeferenciaciones diarias, o fallo de la red o el servidor de `Google` en un momento determinado, u otro motivo similar, la dirección no ha podido ser georeferenciada. Estas direcciones son susceptibles de volver a ser enviadas a `Google` para ser geocodificadas de nuevo.
    
Por este motivo, cuando tratamos de geocodificar con `Google` y no tenemos éxito (`state != "OK"`), nos vamos a guardar además del campo `georef == "NO"` el valor de `state` con el fin de volver a enviar aquellas direcciones que sea necesario en una reejecución posterior de esta parte del protocolo.

El servicio de geocodificacion de `Google`, a diferencia del de `Cartociudad` tiene un límite en el número de geocodificaciones diarias. Dado este límite es posible que esta parte del protocolo deba ser ejecutada dividida en distintos días. Por este motivo nos interesa seleccionar los individuos cuyo estado de la variable `georef` sea `"NO"`, `"NO punto..."`, o cualquier estado que indique que el individuo no está georeferenciado. Sin embargo, debido al fallo en las georeferenciaciones que se produce en `Google` en muchas ocasiones, es importante distinguir entre los distintos tipos de individuos no georeferenciados:

1. Enviados a `Google` con éxito y que no han podido ser georeferenciados: estos registros mantendrán un valor de la variable `georef` que empieza por `"NO"` y un valor en `state` que indica `"ZERO_RESULTS"`. *Estos puntos NO deben volver a ser enviados a `Google` en una nueva ronda de geocodificación*, en caso de volver a ser mandados el resultado que obtendremos será exactamente el mismo.
2. Enviados a `Google` con éxito, georeferenciados, pero con resultado de un punto que no está en el polígono (límite municipal) requerido: estos registros mantendrán un valor de la variable `georef` que empieza por `"NO"` y un valor en `state` que indica `"NO punto google"`. *Estos puntos NO deben volver a ser enviados a `Google` en una nueva ronda de geocodificación*, en caso de volver a ser mandados el resultado que obtendremos será exactamente el mismo, resultado que no consideramos válido.
3. Enviados a `Google` sin éxito, debido a algún fallo del procedimiento como por ejemplo que se ha excedido el límite diario de geocodificaciones: estos registros mantendrán un valor de la variable `georef` que empieza por `"NO"` y un valor en `state` que indica `"OVER_QUERY_LIMIT"` o cualquier otra circunstancia. *Estos puntos SÍ deben volver a ser enviados a `Google` en una nueva ronda de geocodificación* ya que en esa nueva ronda la dirección en cuestión sí podría ser geocodificada.

El proceso de geocodificación mediante `Google` se puede llevar a cabo mediante el siguiente código. A partir del momento que el proceso comience a devolver de forma repetida `"OVER_QUERY_LIMIT"` para, digamos 100 registros, podremos parar el proceso y reanudarlo desde otra máquina otro día ya que habríamos alcanzado el límite máximo diaria de geocodificaciones permitidas. En ese caso no olvides ejecutar la sentencia `save` del final del código para guardar las geocodificaciones efectuadas durante dicha jornada. Al retomar el código durante el día siguiente, las sentencias iniciales seleccionan los registros que quedan por geocodificar o hayan tenido una geocodificación defectuosa previa y sólo intenta la geocodificación de las direcciones correspondientes.

```{r, eval=FALSE}
load(file = "datos/datosfinalescarto/datoscarto.RData")
columnas_elegidas <- c(
      "id", "province", "muni", "tip_via", "address", "portalNumber", "refCatastral",
      "postalCode", "lat", "lng", "stateMsg", "state", "type", "georef"
    )
# Seleccionamos aquellos individuos a georeferenciar que no lo hayan sido antes 
# o hayan sido georeferenciados por Google de forma defectuosa.
no.geo <- which(substr(datosmort$georef, 1, 2) == "NO" & 
                  datosmort$state != "ZERO_RESULTS" & 
                  datosmort$georef != "NO punto google")  
totno.geo <- length(no.geo)

for (i in 1:totno.geo) {
  cont  <- no.geo[i]
  
  direc <- limpiadirecGoogle(datosmort$BOD.direccion[cont]) 

  # Georeferencia con Google con comprobación de que es asignado al interior del polígono
  # correspondiente a la ciudad.
  aux <- geocodificar_google(
    direc    = direc,
    poligono = carto.munis[carto.munis$CUMUN == datosmort$CODMUNIRES[cont], ]
  )
  
  # Para georeferenciar con Google sin más, si no se quisiera cruzar 
  # con los límites geográficos de la ciudad haríamos:
  # aux <- geocodificar_google(direc)
  
  if (aux$georef == "NO punto") {
    datosmort$georef[cont] <- "NO punto google"
  }  
  if (aux$georef == "NO") {#Cuando NO se ha podido georeferenciar con google 
    #recogemos el motivo: "ZERO_RESULTS", "OVER_QUERY_LIMIT",...
    datosmort$state[cont] <- as.character(aux$state)
  }  
  if(!aux$georef %in% c("NO", "NO punto")) {
    datosmort[cont, columnas_elegidas] <- aux
  }
  cat(paste(i, "de", totno.geo, "georef", datosmort$georef[cont], "\n"))
}

save(datosmort, file = "datos/datosfinalescarto/datoscarto.RData")
```
